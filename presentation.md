class: center, middle

# Exploitation binaire (1/2) :
## Attaquer la pile (Smash the stack)

##### Par Frédéric Vachon

---
# Plan de la présentation
* Assembleur x86
	* Mémoire
	* Registres
	* Instructions
* Du C vers l’assembleur
	* Conventions d'appel
	* Cadres d’activation (stack frame)
* Buffer overflow et Exploitation
	* Fonctions vulnérables
	* Changer une variable sur la pile
	* Injection et exécution d’un shellcode
* Introspection
	* Peda
	* Example1
	* Example2

---
class: center, middle
# Assembleur x86
---

# Assembleur x86

* Assembleur : Représentation du langage machine plus sympathique pour l'humain 

* On utilisera la syntaxe Intel (et non AT&T)

* Processeurs x86

	* Processeur Intel 32-bits

	* Petit boutisme (Little Endian)

---
# Mémoire

* Pile d'exécution (stack)
	* Cadres d'activation
		* Variables locales
		* Adresse de retour de fonction

	* Variables d'environnement

* Tas (Heap)
	* Allocations dynamiques (`new`, `malloc`, etc.)

* Code et Données du programme

---

# Registres

* Registres généraux

	* EAX, EBX, ECX, EDX, ESI, EDI

* Registres pour la pile

	* ESP : Pointeur de pile

	* EBP : Pointeur de base de pile

* Pointeur d'instruction

	* EIP

* EFLAGS : Drapeaux d'état

---

# Instructions

## Modes d'adressages importants

```nasm
	mov eax, 0x41414141    ; Adressage immédiat
	mov eax, ebx           ; Adressage par registre
	mov eax, [ebx]         ; Adressage direct
	mov eax, [ebx+8]       ; Adressage direct avec arithmétique de pointeur 
```
## Déplacement de données

```nasm
	mov eax, 0x41414141 ; Met 0x41414141 dans eax

	lea ebx, [eax+1] ; Met le contenu de eax + 1 dans ebx
```


---

## Arithmétique de base

### Addition / Soustraction

```nasm
	add eax, ebx ; eax += ebx

	sub ebx, 0x2 ; ebx -= 2

	inc edx ; edx += 1

	dec edx ; edx -= 1
```

## Manipulation de la pile

```nasm
	push eax ; rsp += 4; *rsp = eax
	pop eax ; eax = *rsp; rsp -= 4
```

---

## Comparaisons et Branchements


* Le branchement est pris si la condition est vraie
* Sauf pour `jmp` qui est un sauf inconditionnel

```nasm
	; Test de pointeur null
	test eax, eax ; Si eax = 0 le résultat est considéré comme une égalité

	cmp eax, ebx

	jz 0x08040110  ; Si eax == ebx
	je 0x08040110  ; Si eax == ebx
	jne 0x08040110 ; Si eax != ebx
	jnz 0x08040110 ; Si eax != ebx

	; Signé
	jg 0x08040110  ; Si eax > ebx
	jge 0x08040110 ; Si eax >= ebx
	jl 0x08040110  ; Si eax < ebx
	jle 0x08040110 ; Si eax <= ebx

	; Non-signé
	ja 0x08040110  ; Si eax > ebx
	jae 0x08040110 ; Si eax >= ebx
	jb 0x08040110  ; Si eax < ebx
	jbe 0x08040110 ; Si eax <= ebx

	jmp 0x08040110 ; eip = 0x08040110
```

---

## Appel de Fonction et retour

* Un appel de fonction se fait avec la mnémonique : `call`

* Le retour d'une fonction se fait via : `ret`


```nasm
main:
	add eax, 1
	call ma_fonction 
	; Après le l'appel à ret
	sub eax, 1

```

```nasm
ma_fonction:
	push ebp
	mov ebp, esp
	; ...
	; Corps de ma fonction
	; ...
	pop ebp
	ret
```

---

class: center, middle
# Du C vers l'assembleur

---

# Conventions d'appel

* Convention qui définit :
	* Comment passer les paramètres
	* Comment retourner la valeur de retour
	* Qui nettoie la pile

* Il existe plusieurs conventions d'appel : cdecl, stdcall, fastcall, thiscall, System V AMD64 ABI, etc.

* Nous verrons cdecl et System V AMD64 ABI

---

## CDECL

* Les paramètres sont passés par la pile dans l'ordre inverse

* L'appelant a la responsabilité de nettoyer la pile

* Valeur de retour dans eax

* `memset(buffer, 0, 0x20)`

```nasm
   sub    esp,0x4
   push   0x20
   push   0x0
   lea    eax,[ebp-0x30]
   push   eax
   call   0x8048310 <memset@plt>
   add    esp,0x10
```

---

## System V AMD64 ABI

* Convention d'appel pour x86-64 (64 bits)

* C'est la même convention pour faire des appels systèmes
	* Le numéro de l'appel système est dans rax

* Les paramètres sont passés par les registres
	* 1er param : rdi
	* 2e param : rsi
	* 3e param : rdx
	* 4e param : rcx
	* ...

* Valeur de retour dans rax

* `memset(buffer, 0, 0x20)`

```nasm
   lea    rax,[rbp-0x30]
   mov    edx,0x20
   mov    esi,0x0
   mov    rdi,rax
   call   0x400410 <memset@plt>
```

---

# Cadres d’activation (stack frame)

```C
int main() {
	volatile int a = 0x10;
	volatile int b = 0x20;
	char buffer[0x20];

	memset(buffer, 0, 0x20);

	return 0;
}
```

```nasm
main:
   push   ebp
   mov    ebp,esp
   sub    esp,0x30
   mov    DWORD PTR [ebp-0x4],0x10
   mov    DWORD PTR [ebp-0x8],0x20
   lea    eax,[ebp-0x30]
   push   0x20
   push   0x0
   push   eax
   call   0x400410 <memset@plt>
   mov    eax,0x0
   leave  
   ret    
```

---

class: center, middle
# Buffer overflow et Exploitation
---

# Fonctions vulnérables

* Un buffer overflow survient lorsqu'un programme met plus de données dans un buffer que l'espace disponible

* Certaines fonctions vulnérables :
	* `strcpy(char *dest, const char *src)`
	* `strcat(char *dest, const char *src)`
	* `gets(char *s)`
	* `sprintf(char *str, const char *format, ...)`
	* `vsprintf(char *str, const char *format, va_list ap);`

* Mais les versions 'n' sont aussi vulnérables si l'utilisateur contrôle le 'n'
	* `strncpy(char *dest, const char *src, size_t n)`
	* `strncat(char *dest, const char *src, size_t n)`
	* `snprintf(char *str, size_t size, const char *format, ...)`
	* `vsnprintf(char *str, size_t size, const char *format, va_list ap)`

---

# Changer une variable sur la pile

* État de la pile avant l'appel à `gets`

<img src="./img/stack0-before.png" align="middle" height="100%" width="100%"/>

---

# Changer une variable sur la pile

* Si j'envoie : 
```bash
$ python -c 'print "A" * 64 + "B" * 4' | ./stack0
```

<img src="./img/stack0.png" align="middle" height="100%" width="100%"/>

---

<img src="./img/ascii_table.png" align="middle" height="100%" width="100%"/>
---
# Injection et exécution d’un shellcode

* On injecte un shellcode dans notre buffer
	* Un shellcode est du code machine qui lance généralement un interpréteur ligne de commande
	* `execve("/bin/sh", {"/bin/sh", NULL}, NULL);`
	* BD de shellcodes : http://shell-storm.org/shellcode/

* On doit connaître l'adresse de notre shellcode

* Les adresses de pile dans `gdb` ne sont pas exactement les mêmes que lorsqu'il n'y a pas de déboggueur
	* Précéder le shellcode d'une NOP sled (0x90 en hexadécimal)

* On essaie de trouver une adresse qui pointe dans notre NOP sled

---

# Injection et exécution d’un shellcode

<img src="./img/shellcode.png" align="middle" height="70%" width="70%"/>


---

class: center, middle
# Introspection
---

# Introspection


* Utilisation de PEDA
	* Python Exploit Development Assistance for GDB
	* Surcouche de fonctionnalités pour GDB

* Tracing
	* `ltrace` : Voir tous les appels à des librairies dynamiques
	* `strace` : Voir tous les appels systèmes

---

# Lancer le débogueur avec nos données

* Envoyer des données au programme

	* Par l'entrée standard
```bash
# Dans gdb
gdb-peda$ run < fichier_avec_donnees
```

	* En arguments au programme
```bash
# Dans le shell
$ gdb --args monprogramme arg1 arg2
$ gdb --args monprogramme $(echo -e "\xAA\xBB\xCC\xDD")
```
```bash
# Dans gdb
gdb-peda$ run arg1 arg2 arg3
gdb-peda$ run $(echo -e "\xAA\xBB\xCC\xDD")
```

---


# Commandes Peda

```bash
# Démarrer le programme et arrêter dans le main ou le point d'entrée
start

# Désassembler une fonction
pdisass main

# Mettre des breakpoints
b nom_de_la_fonction
b *0x080484a2

# Continuer l'exécution
continue
c

# Exécution pas à pas
nexti
ni

# Voir le contexte
context
context_code
context_stack
context_register

# En savoir plus
phelp
```

---

# Example 1

```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

---
# Commande Examine

* Utilisation : "`x/[nb d'unités][taille de l'unité][représentation]`"

* Taille de l'unité
	* 'b' pour byte (1 octet)
	* 'h' pour half-word (2 octets)
	* 'w' pour word (4 octets)
	* 'g' pour giant word (8 octets)

* Représentation (Même format que printf)
	* 'x' pour hexadecimal
	* 'd' pour entier
	* 's' pour chaîne de caractères
	* 'i' pour instructions

```bash
gdb-peda$ x/4bx 0x8048405
0x8048405 <main+17>:	0x8d	0x44	0x24	0x1c

gdb-peda$ stack [nb valeurs]
```

---

# Example 2

```C
#include <stdio.h>

void victoire() {
	puts("Victoire!");
}

int main() {
	char buffer[0x10];

	gets(buffer);

	return 0;
}
```

---
# Démo : Tracing

* `ltrace` pour le bin02 des CSGAMES 2016

* `strace -i` pour voir si on contrôle bien l'adresse de retour

---

# Conclusion

* Il existe des mécanismes de protections contre les attaques visant la pile
	* NX : Pile non exécutable
	* ASLR : Adresses mémoires aléatoires à chaque nouvelle exécution
	* Stack cookie : Valeur sur la pile avant l'adresse de retour voulant garantir l'intégrité de la pile

* Des techniques permettent de contourner ces protections

* Ce sera le sujet de Exploitation Binaire (2/2)

