class: center, middle

# Exploitation binaire (1/2) :
## Attaquer la pile (Smash the stack)

##### Par Frédéric Vachon

---
# Plan de la présentation
* Assembleur x86
	* Mémoire
	* Registres
	* Instructions
* Du C vers l’assembleur
	* Cadres d’activation (stack frame)
	* Appels de fonctions
	* Conditions
* Buffer overflow et Exploitation
	* Fonctions vulnérables
	* Changer une variable sur la pile
	* Contrôler l’adresse de retour
	* Injection et exécution d’un shellcode
* Introspection

---
class: center, middle
# Assembleur x86
---

# Mémoire

<img src="./img/memlayout.png" align="middle" height="55%" width="55%"/>

---

# Registres

* Registres généraux
	* EAX, EBX, ECX, EDX, ESI, EDI
	* EAX => AX, AH, AL
* Registres pour la pile
	* ESP : Pointeur de pile
	* EBP : Pointeur de base de pile
* Pointeur d'instruction
	* EIP
* EFLAGS : Drapeaux d'état

---

# Instructions



* Syntaxe Intel (assembly flavor)

* Architecture CISC (Complex Instruction Set Computer)

* Des centaines d'instructions

* On ne les verra pas toutes...

---

# Instructions

## Déplacement de données

```nasm
	mov eax, 0x41414141 ; Met 0x41414141 dans eax
	mov eax, ebx ; Met le contenu de ebx dans eax
	mov eax, [ebx] ; Met la valeur pointée par ebx dans eax

	lea ebx, [eax+1] ; Met le contenu de eax + 1 dans ebx
```

## Manipulation de la pile

```nasm
	push eax ; rsp += 4; *rsp = eax

	pop eax ; eax = *rsp; rsp -= 4
```

---

## Arithmétique de base

### Addition / Soustraction

```nasm
	add eax, ebx ; eax += ebx

	sub ebx, 0x2 ; ebx -= 2

	inc edx ; edx += 1

	dec edx ; edx -= 1
```

### Multiplication / Division

```nasm
	mul 0x10 ; edx:eax = eax * 0x10
	imul 0x10 ; version signée
```

```nasm
	div ebx  ; edx:eax / ebx => eax = quotient; edx = reste
	idiv ebx ; version signée
```

---

## Comparaisons et sauts

### Saut inconditionnel

```nasm
	jmp 0x08040110 ; eip = 0x08040110
	jmp [eax] ; eip = *eax
```

### Comparaison

```nasm
	cmp eax, ebx ; Compare eax et ebx et modifie les EFLAGS conséquemment

	; Test de pointeur null
	test eax, eax ; ZF = 1 si eax = 0
```

---

### Sauts conditionnels

* Le saut est pris si la condition est vraie

```nasm
	cmp eax, ebx

	jz 0x08040110  ; Si eax == ebx
	je 0x08040110  ; Si eax == ebx
	jne 0x08040110 ; Si eax != ebx
	jnz 0x08040110 ; Si eax != ebx

	; Signé
	jg 0x08040110  ; Si eax > ebx
	jge 0x08040110 ; Si eax >= ebx
	jl 0x08040110  ; Si eax < ebx
	jle 0x08040110 ; Si eax <= ebx

	; Non-signé
	ja 0x08040110  ; Si eax > ebx
	jae 0x08040110 ; Si eax >= ebx
	jb 0x08040110  ; Si eax < ebx
	jbe 0x08040110 ; Si eax <= ebx
```

---

## Appel de Fonction et retour

* Un appel de fonction se fait avec la mnémonique : `call`

* Le retour d'une fonction se fait via : `ret`


```nasm
main:
	add eax, 1
	call ma_fonction 
	; Après le l'appel à ret
	sub eax, 1

```

```nasm
ma_fonction:
	push ebp
	mov ebp, esp
	; ...
	; Corps de ma fonction
	; ...
	pop ebp
	ret
```

---

class: center, middle
# Du C vers l'assembleur

---

# Cadres d’activation (stack frame)

```C
int main() {
	volatile int a = 0x10;
	volatile int b = 0x20;
	char buffer[0x20];

	memset(buffer, 0, 0x20);

	return 0;
}
```

```nasm
main:
   push   ebp
   mov    ebp,esp
   sub    esp,0x30
   mov    DWORD PTR [ebp-0x4],0x10
   mov    DWORD PTR [ebp-0x8],0x20
   lea    eax,[ebp-0x30]
   mov    edx,0x20
   mov    esi,0x0
   mov    edi,eax
   call   0x400410 <memset@plt>
   mov    eax,0x0
   leave  
   ret    
```

---

# Appels de fonctions

* Convention qui défini comment passer les paramètres et qui doit nettoyer la pile

* Il existe plusieurs conventions d'appel : cdecl, stdcall, fastcall, thiscall, System V AMD64 ABI, etc.

* Nous verrons cdecl et System V AMD64 ABI

---

## CDECL

* Les paramètres sont passés par la pile dans l'ordre inverse

* L'appelant a la responsabilité de nettoyer la pile

* Valeur de retour dans eax

```nasm
   sub    esp,0x4
   push   0x20
   push   0x0
   lea    eax,[ebp-0x30]
   push   eax
   call   0x8048310 <memset@plt>
   add    esp,0x10
```

---

## System V AMD64 ABI

* Convention d'appel pour x86-64 (64 bits)

* C'est la même convention pour faire des appels systèmes
	* Le numéro de l'appel système est dans rax

* Les paramètres sont passés par les registres
	* rdi, rsi, rdx, rcx, r8, r9

* Valeur de retour dans rax

```nasm
   lea    rax,[rbp-0x30]
   mov    edx,0x20
   mov    esi,0x0
   mov    rdi,rax
   call   0x400410 <memset@plt>
```

---

# Conditions

```C
int main() {
	volatile int a = 0x10;
	volatile int b = 0x20;

	if (a == 0x10) {
		a = 20;
	} else if (b == 0x20) {
		b = 10;
	}

	return 0;
}
```

```nasm
	cmp eax, 0x10             ;      0x08048402 
	jne 0x8048410             ;  ,=< 0x08048405 
	mov dword [ebp - 4], 0x14 ;  |   0x08048407 
	jmp 0x804841f             ; ,==< 0x0804840e 
	mov eax, dword [ebp - 8]  ; |`-> 0x08048410 
	cmp eax, 0x20             ; |    0x08048413 
	jne 0x804841f             ; |,=< 0x08048416 
	mov dword [ebp - 8], 0xa  ; ||   0x08048418 
	mov eax, 0                ; ``-> 0x0804841f 
```

---

## Control Flow Graph (CFG)

<img src="./img/ida_ifelse.png" align="middle" height="65%" width="65%"/>

---

class: center, middle
# Buffer overflow et Exploitation
---

# Fonctions vulnérables

* Un buffer overflow survient lorsqu'un programme tente de mettre plus de données dans un buffer que l'espace qui est disponible

* Certaines fonctions vulnérables :
	* `strcpy(char *dest, const char *src)`
	* `strcat(char *dest, const char *src)`
	* `gets(char *s)`
	* `sprintf(char *str, const char *format, ...)`
	* `vsprintf(char *str, const char *format, va_list ap);`

* Mais les versions 'n' sont aussi vulnérables si l'utilisateur contrôle le 'n'
	* `strncpy(char *dest, const char *src, size_t n)`
	* `strncat(char *dest, const char *src, size_t n)`
	* `sprintf(char *str, const char *format, ...)`
	* `vsnprintf(char *str, size_t size, const char *format, va_list ap)`

---

# Changer une variable sur la pile

* État de la pile avant l'appel à `gets`

<img src="./img/stack0-before.png" align="middle" height="100%" width="100%"/>

---

# Changer une variable sur la pile

* Si j'envoie : 
```bash
$ python -c 'print "A" * 64 + "B" * 4' | ./stack0
```

<img src="./img/stack0.png" align="middle" height="100%" width="100%"/>

---

# Contrôler l’adresse de retour

* On veut écraser l'adresse de retour pour contrôler EIP

* Lorsque l'instruction `ret` ou le `return` en C, l'adresse injectée se retrouve dans EIP

```C
void victoire() {       // Adresse de la fonction 0x08041020
	puts("Victoire"!);
}

int main() {
	char buffer[0x10];

	gets(buffer);

	return 0;
}
```

---

# Contrôler l’adresse de retour

* Si j'envoie : 

```bash
$ python -c 'print "A" * 0x14 + "\x20\x10\x04\x08"' | ./stack0
```

<img src="./img/return.png" align="middle" height="70%" width="70%"/>

---

# Injection et exécution d’un shellcode

* On injecte un shellcode dans notre buffer
	* Un shellcode est du code machine qui lance généralement un interpréteur ligne de commande
	* `execve("/bin/sh", NULL, NULL);`
	* BD de shellcodes : http://shell-storm.org/shellcode/

* On doit connaître l'adresse de notre shellcode

* Les adresses de pile dans `gdb` ne sont pas exactement les mêmes que lorsqu'il n'y a pas de déboggueur
	* Précéder le shellcode d'une NOP sled (0x90 en hexadécimal)

* On essaie de trouver une adresse qui pointe dans notre NOP sled

---

# Injection et exécution d’un shellcode

<img src="./img/shellcode.png" align="middle" height="70%" width="70%"/>


---

class: center, middle
# Introspection
---

# Introspection


* Utilisation de `peda/p3da`
	* Python Exploit Development Assistance for GDB
	* Surcouche de fonctionnalités pour GDB

* Tracing
	* `ltrace` : Voir tous les appels à des librairies dynamiques
	* `strace` : Voir tous les appels systèmes

---

# Commandes P[e|3]da


```bash
# Démarrer le programme et arrêter dans le main ou le point d'entrée
start

# Désassembler une fonction
pdisass main

# Mettre des breakpoints
b nom_de_la_fonction
b *0x080484a2

# Continuer l'exécution
continue
c

# Exécution pas à pas
nexti
ni

# Voir le contexte
context
context_code
context_stack
context_register

# En savoir plus
phelp
```

---

# Commande Examine

* Utilisation : "`x/[nb d'unités][représentation][taille de l'unité]`"

* Représentation (Même format que printf)
	* 'x' pour hexadecimal
	* 'd' pour entier
	* 's' pour chaîne de caractères
	* 'i' pour instructions

* Taille de l'unité
	* 'b' pour byte (1 octet)
	* 'h' pour half-word (2 octets)
	* 'w' pour word (4 octets)
	* 'g' pour giant word (8 octets)


```bash
gdb-peda$ x/4bx 0x8048405
0x8048405 <main+17>:	0x8d	0x44	0x24	0x1c
```

---

# Démo : Tracing

* `ltrace` pour le bin02 des CSGAMES 2016

* `strace -i` pour voir si on contrôle bien l'adresse de retour


